diff --git a/src/alloc.c b/src/alloc.c
index ce24b8ec..b3d6d9f9 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -579,6 +579,24 @@ mi_decl_nodiscard void* mi_new_reallocn(void* p, size_t newcount, size_t size) {
   }
 }
 
+bool mi_heap_page_is_underutilized(mi_heap_t* heap, void* p, float ratio) mi_attr_noexcept {
+  mi_page_t* page = _mi_ptr_page(p);   // get the page that this belongs to
+
+  mi_heap_t* page_heap = (mi_heap_t*)(mi_atomic_load_acquire(&(page)->xheap));
+
+  // the heap id matches and it is not a full page
+  if (mi_likely(page_heap == heap && page->flags.x.in_full == 0)) {
+    // first in the list, meaning it's the head of page queue, thus being used for malloc
+    if (page->prev == NULL)
+      return false;
+
+    // this page belong to this heap and is not first in the page queue. Lets check its
+    // utilization.
+    return page->used <= (unsigned)(page->capacity * ratio);
+  }
+  return false;
+}
+
 // ------------------------------------------------------
 // ensure explicit external inline definitions are emitted!
 // ------------------------------------------------------
@@ -586,11 +604,13 @@ mi_decl_nodiscard void* mi_new_reallocn(void* p, size_t newcount, size_t size) {
 #ifdef __cplusplus
 void* _mi_externs[] = {
   (void*)&_mi_page_malloc,
+  (void*)&_mi_page_malloc_zero,
   (void*)&_mi_heap_malloc_zero,
   (void*)&_mi_heap_malloc_zero_ex,
   (void*)&mi_malloc,
   (void*)&mi_malloc_small,
   (void*)&mi_zalloc_small,
+  (void*)&mi_heap_calloc,
   (void*)&mi_heap_malloc,
   (void*)&mi_heap_zalloc,
   (void*)&mi_heap_malloc_small
